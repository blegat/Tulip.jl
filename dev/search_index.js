var documenterSearchIndex = {"docs":
[{"location":"manual/formulation/#Problem-formulation-1","page":"Problem formulation","title":"Problem formulation","text":"","category":"section"},{"location":"manual/formulation/#Model-input-1","page":"Problem formulation","title":"Model input","text":"","category":"section"},{"location":"manual/formulation/#","page":"Problem formulation","title":"Problem formulation","text":"Tulip takes as input LP problems of the form","category":"page"},{"location":"manual/formulation/#","page":"Problem formulation","title":"Problem formulation","text":"    beginarrayrrcll\n    (P)    \n    displaystyle min_x  c^Tx  +  c_0\n    st\n     l^b_i leq  a_i^T x  leq u^b_i  forall i = 1  m\n     l^x_j leq  x_j  leq u^x_j  forall j = 1  n\n    endarray","category":"page"},{"location":"manual/formulation/#","page":"Problem formulation","title":"Problem formulation","text":"where l^bx u^b x in mathbbR cup  - infty + infty , i.e., some of the bounds may be infinite.","category":"page"},{"location":"manual/formulation/#","page":"Problem formulation","title":"Problem formulation","text":"This original formulation is then converted to standard form.","category":"page"},{"location":"manual/formulation/#Standard-form-1","page":"Problem formulation","title":"Standard form","text":"","category":"section"},{"location":"manual/formulation/#","page":"Problem formulation","title":"Problem formulation","text":"Internally, Tulip solves LPs of the form","category":"page"},{"location":"manual/formulation/#","page":"Problem formulation","title":"Problem formulation","text":"    beginarrayrl\n    (P)    \n    displaystyle min_x\n     c^T x +  c_0\n    st\n     A x = b\n     x leq u\n     x geq 0\n    endarray","category":"page"},{"location":"manual/formulation/#","page":"Problem formulation","title":"Problem formulation","text":"where x c u in mathbbR^n, A in mathbbR^m times n and b in mathbbR^m. Some u_j may may take infinite value, i.e., the corresponding variable x_j has no upper bound.","category":"page"},{"location":"manual/formulation/#","page":"Problem formulation","title":"Problem formulation","text":"The original problem is automatically reformulated into standard form before the optimization is performed. This transformation is transparent to the user.","category":"page"},{"location":"reference/parameters/#","page":"Parameters","title":"Parameters","text":"CurrentModule = Tulip","category":"page"},{"location":"reference/parameters/#Parameters-1","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"reference/parameters/#","page":"Parameters","title":"Parameters","text":"Parameters can be queried and set through the get_parameter and set_parameter functions.","category":"page"},{"location":"reference/parameters/#","page":"Parameters","title":"Parameters","text":"In all that follows, epsilon refers to the numerical precision, which is given by eps(Tv) where Tv is the arithmetic of the current model. For instance, in double-precision arithmetic, i.e., Tv=Float64, we have epsilon simeq 10^-16.","category":"page"},{"location":"reference/parameters/#Tolerances-1","page":"Parameters","title":"Tolerances","text":"","category":"section"},{"location":"reference/parameters/#","page":"Parameters","title":"Parameters","text":"Numerical tolerances for the interior-point algorithm.","category":"page"},{"location":"reference/parameters/#","page":"Parameters","title":"Parameters","text":"Parameter Description Default\nBarrierTolerancePFeas Primal feasibility tolerance sqrtepsilon\nBarrierToleranceDFeas Dual feasibility tolerance sqrtepsilon\nBarrierToleranceRGap Relative optimality gap tolerance sqrtepsilon\nBarrierToleranceIFeas Infeasibility tolerance sqrtepsilon","category":"page"},{"location":"reference/parameters/#Algorithmic-parameters-1","page":"Parameters","title":"Algorithmic parameters","text":"","category":"section"},{"location":"reference/parameters/#","page":"Parameters","title":"Parameters","text":"Parameter Description Default\nBarrierAlgorithm Interior-point algorithm 1\nBarrierCorrectionLimit Maximum number of additional centrality corrections 5\nBarrierStepDampFactor Step 0.9995\nBarrierGammaMin Minimum value of gamma for computing correctors 0.1\nBarrierCentralityOutlierThreshold Relative threshold for computing extra centrality corrections 0.1\nBarrierPRegMin Minimum value of primal regularization sqrtepsilon\nBarrierDregMin Minimum value of dual regularization sqrtepsilon","category":"page"},{"location":"reference/parameters/#Stopping-criterion-1","page":"Parameters","title":"Stopping criterion","text":"","category":"section"},{"location":"reference/parameters/#","page":"Parameters","title":"Parameters","text":"Parameter Description Default\nBarrierIterationsLimit Maximum number of barrier iterations 100\nTimeLimit Time limit, in seconds Inf","category":"page"},{"location":"reference/parameters/#Linear-solvers-1","page":"Parameters","title":"Linear solvers","text":"","category":"section"},{"location":"reference/parameters/#","page":"Parameters","title":"Parameters","text":"Parameter Description Default\nLinearSolverBackend Backend for solving linear systems Tulip.TLPLinearAlgebra.DefaultBackend\nLinearSolverSystem Linear system solved Tulip.TLPLinearAlgebra.DefaultSystem","category":"page"},{"location":"reference/parameters/#Others-1","page":"Parameters","title":"Others","text":"","category":"section"},{"location":"reference/parameters/#","page":"Parameters","title":"Parameters","text":"Parameter Description Default\nOutputLevel Controls the solver's output 0\nThreads Maximum number of threads 1\nPresolve Presolve (no presolve if set to ≤ 0) 1","category":"page"},{"location":"reference/API/#","page":"Julia API","title":"Julia API","text":"Modules = [Tulip]\nPages = [\"tulip_julia_api.jl\"]","category":"page"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.BarrierIterations}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::BarrierIterations)\n\nQuery the BarrierIterations attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.ConstraintName,Int64}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(m::Model, ::ConstraintName, i::Int)\n\nQuery the name of constraint i in model m\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.ModelName}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::ModelName)\n\nQuery the ModelName attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.Status}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::Status)\n\nQuery the Status attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.VariableLowerBound,Int64}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(m::Model{Tv}, ::VariableLowerBound, j::Int)\n\nQuery the lower bound of variable j in model m.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.VariableName,Int64}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(m::Model, ::VariableName, j::Int)\n\nQuery the name of variable j in model m\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},Tulip.DualObjectiveValue}} where Tv","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::DualObjectiveValue)\n\nQuery the DualObjectiveValue attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},Tulip.ObjectiveValue}} where Tv","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::ObjectiveValue)\n\nQuery the ObjectiveValue attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_parameter-Tuple{Tulip.Model,String}","page":"Julia API","title":"Tulip.get_parameter","text":"get_parameter(m::Model, pname::String)\n\nQuery the value of parameter pname in model m.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.load_problem!-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},String}} where Tv","page":"Julia API","title":"Tulip.load_problem!","text":"load_problem!(m::Model{Tv}, fname::String)\n\nRead a model from file fname and load it into model m.\n\nOnly free MPS files are currently supported.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Tuple{Tulip.Model,Tulip.ConstraintName,Int64,String}","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model, ::ConstraintName, i::Int, name::String)\n\nSet the name of constraint i in model m to name.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Tuple{Tulip.Model,Tulip.ModelName,String}","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(model::Model, ::ModelName, name::String)\n\nSet the ModelName attribute in model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Tuple{Tulip.Model,Tulip.VariableName,Int64,String}","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model, ::VariableName, j::Int, name::String)\n\nSet the name of variable j in model m to name.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},Tulip.ConstraintLowerBound,Int64,Tv}} where Tv","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{Tv}, ::ConstraintLowerBound, i::Int, lb::Tv)\n\nSet the lower bound of constraint i in model m to lb.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},Tulip.ConstraintUpperBound,Int64,Tv}} where Tv","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{Tv}, ::ConstraintUpperBound, i::Int, ub::Tv)\n\nSet the upper bound of constraint i in model m to ub.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},Tulip.VariableLowerBound,Int64,Tv}} where Tv","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{Tv}, ::VariableLowerBound, j::Int, lb::Tv)\n\nSet the lower bound of variable j in model m to lb.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},Tulip.VariableUpperBound,Int64,Tv}} where Tv","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{Tv}, ::VariableUpperBound, j::Int, ub::Tv)\n\nSet the upper bound of variable j in model m to ub.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_parameter-Tuple{Tulip.Model,String,Any}","page":"Julia API","title":"Tulip.set_parameter","text":"set_parameter(m::Model, pname::String, val)\n\nSet the value of parameter pname in model m to val\n\n\n\n\n\n","category":"method"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"CurrentModule = Tulip.TLPLinearAlgebra","category":"page"},{"location":"manual/linear_systems/#Solving-linear-systems-1","page":"Solving linear systems","title":"Solving linear systems","text":"","category":"section"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"The interior-point algorithm in Tulip requires the solution, at each iteration, of the following symmetric quasi-definite augmented system","category":"page"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"beginbmatrix\n    -(Theta^-1 + R_p)  A^T\n    A  R_d\nendbmatrix\nbeginbmatrix\n    Delta x\n    Delta y\nendbmatrix\n=\nbeginbmatrix\n    xi_d\n    xi_p\nendbmatrix","category":"page"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"where","category":"page"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"Delta x Delta y are primal and dual search directions,\nA is the problem's constraint matrix,\nTheta, R_p and R_d are positive diagonal matrices,\nxi_p xi_d are right-hand side vectors.","category":"page"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"The augmented system above can be reduced to the positive-definite normal equations system","category":"page"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"beginarrayrl\nleft(\n    A (Theta^-1 + R_p)^-1 A^T + R_d\nright)\nDelta y\n =\nxi_p + A (Θ^-1 + R_p)^-1 xi_d\nDelta x = (Θ^-1 + R_p)^-1 (A^T Delta y - xi_d)\nendarray","category":"page"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"When selected, this reduction is transparent to the interior-point algorithm.","category":"page"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"To enable the use of fast external libraries and/or specialized routines, the resolution of linear systems is performed by a linear solver object. Linear solvers can be customized with the options below.","category":"page"},{"location":"manual/linear_systems/#Linear-solver-options-1","page":"Solving linear systems","title":"Linear solver options","text":"","category":"section"},{"location":"manual/linear_systems/#System-1","page":"Solving linear systems","title":"System","text":"","category":"section"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"LinearSystem","category":"page"},{"location":"manual/linear_systems/#Tulip.TLPLinearAlgebra.LinearSystem","page":"Solving linear systems","title":"Tulip.TLPLinearAlgebra.LinearSystem","text":"LinearSystem\n\nIndicates which linear system is solved.\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"DefaultSystem","category":"page"},{"location":"manual/linear_systems/#Tulip.TLPLinearAlgebra.DefaultSystem","page":"Solving linear systems","title":"Tulip.TLPLinearAlgebra.DefaultSystem","text":"DefaultSystem\n\nChoose linear system to be solved using default option.\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"AugmentedSystem","category":"page"},{"location":"manual/linear_systems/#Tulip.TLPLinearAlgebra.AugmentedSystem","page":"Solving linear systems","title":"Tulip.TLPLinearAlgebra.AugmentedSystem","text":"AugmentedSystem\n\nSolve the augmented system, i.e., without reducing to normal equations.\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"NormalEquations","category":"page"},{"location":"manual/linear_systems/#Tulip.TLPLinearAlgebra.NormalEquations","page":"Solving linear systems","title":"Tulip.TLPLinearAlgebra.NormalEquations","text":"NormalEquations\n\nSolve the normal equations system.\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_systems/#Backend-1","page":"Solving linear systems","title":"Backend","text":"","category":"section"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"LSBackend","category":"page"},{"location":"manual/linear_systems/#Tulip.TLPLinearAlgebra.LSBackend","page":"Solving linear systems","title":"Tulip.TLPLinearAlgebra.LSBackend","text":"LSBackend\n\nBackend used for solving linear systems.\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"DefaultBackend","category":"page"},{"location":"manual/linear_systems/#Tulip.TLPLinearAlgebra.DefaultBackend","page":"Solving linear systems","title":"Tulip.TLPLinearAlgebra.DefaultBackend","text":"DefaultBackend\n\nChose linear solver backend automatically.\n\nFor A::Matrix{Tv}, defaults to Lapack (i.e., dense solver).\nFor A::AbstractMatrix{Float64}, defaults to Cholmod\nOtherwise, defaults to LDLFact\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"Lapack","category":"page"},{"location":"manual/linear_systems/#Tulip.TLPLinearAlgebra.Lapack","page":"Solving linear systems","title":"Tulip.TLPLinearAlgebra.Lapack","text":"Lapack <: LSBackend\n\nUse LAPACK backend.\n\nOptions available:\n\nNumerical precision: Tv<:Real\nFloat32 and Float64 will use LAPACK.\nOther numerical types will use Julia's generic cholesky factorization.\nNormalEquations only, with Cholesky factorization\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"Cholmod","category":"page"},{"location":"manual/linear_systems/#Tulip.TLPLinearAlgebra.Cholmod","page":"Solving linear systems","title":"Tulip.TLPLinearAlgebra.Cholmod","text":"Cholmod <: LSBackend\n\nUse CHOLMOD backend.\n\nOptions available:\n\nFloat64 only\nAugmented system with LDLᵀ factorization\nNormal equations with Cholesky factorization\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"LDLFact","category":"page"},{"location":"manual/linear_systems/#Tulip.TLPLinearAlgebra.LDLFact","page":"Solving linear systems","title":"Tulip.TLPLinearAlgebra.LDLFact","text":"LDLFact <: LSBackend\n\nUse LDLFactorizations backend.\n\nOptions available:\n\nAny numerical type T\nAugmented system with LDLᵀ factorization\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_systems/#-1","page":"Solving linear systems","title":"","text":"","category":"section"},{"location":"manual/linear_systems/#Supported-linear-solvers-1","page":"Solving linear systems","title":"Supported linear solvers","text":"","category":"section"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"Here is a list of currently supported linear solvers:","category":"page"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"Linear solver type Tv System LSBackend Method\nDenseLinearSolver Real NormalEquations Lapack Cholesky\nSparseIndefLinearSolver Float64 AugmentedSystem Cholmod LDLᵀ\nSparsePosDefLinearSolver Float64 NormalEquations Cholmod Cholesky\nLDLFLinearSolver Real AugmentedSystem LDLFact LDLᵀ","category":"page"},{"location":"manual/linear_systems/#Default-options-1","page":"Solving linear systems","title":"Default options","text":"","category":"section"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"If no option is specified, then the linear solver is chosen as follows:","category":"page"},{"location":"manual/linear_systems/#","page":"Solving linear systems","title":"Solving linear systems","text":"A is dense: DenseLinearSolver\nIf A sparse and Tv is Float64: SparseIndefLinearSolver\nAll other cases: LDLFLinearSolver","category":"page"},{"location":"reference/attributes/#","page":"Attributes","title":"Attributes","text":"CurrentModule = Tulip","category":"page"},{"location":"reference/attributes/#Attribute-reference-1","page":"Attributes","title":"Attribute reference","text":"","category":"section"},{"location":"reference/attributes/#","page":"Attributes","title":"Attributes","text":"Attributes are queried using get_attribute and set using set_attribute.","category":"page"},{"location":"reference/attributes/#Model-attributes-1","page":"Attributes","title":"Model attributes","text":"","category":"section"},{"location":"reference/attributes/#","page":"Attributes","title":"Attributes","text":"Name Type Description\nModelName String Name of the model\nNumberOfConstraints Int Number of constraints in the model\nNumberOfVariables Int Number of variables in the model\nObjectiveValue Tv Objective value of the current primal solution\nDualObjectiveValue Tv Objective value of the current dual solution\nObjectiveConstant Tv Value of the objective constant\nObjectiveSense  Optimization sense\nStatus  Model status\nBarrierIterations Int Number of barrier iterations\nSolutionTime Float64 Solution time, in seconds","category":"page"},{"location":"reference/attributes/#Variable-attributes-1","page":"Attributes","title":"Variable attributes","text":"","category":"section"},{"location":"reference/attributes/#","page":"Attributes","title":"Attributes","text":"Name Type Description\nVariableLowerBound Tv Variable lower bound\nVariableUpperBound Tv Variable upper bound\nVariableObjectiveCoeff Tv Variable objective coefficient\nVariableName String Variable name","category":"page"},{"location":"reference/attributes/#Constraint-attributes-1","page":"Attributes","title":"Constraint attributes","text":"","category":"section"},{"location":"reference/attributes/#","page":"Attributes","title":"Attributes","text":"Name Type Description\nConstraintLowerBound Tv Constraint lower bound\nConstraintUpperBound Tv Constraint upper bound\nConstraintName String Constraint name","category":"page"},{"location":"reference/attributes/#Reference-1","page":"Attributes","title":"Reference","text":"","category":"section"},{"location":"reference/attributes/#Model-attributes-2","page":"Attributes","title":"Model attributes","text":"","category":"section"},{"location":"reference/attributes/#","page":"Attributes","title":"Attributes","text":"Modules = [Tulip]\nPages = [\"src/Core/attributes.jl\"]\nFilter = t -> typeof(t) === DataType && t <: Tulip.AbstractModelAttribute","category":"page"},{"location":"reference/attributes/#Tulip.BarrierIterations","page":"Attributes","title":"Tulip.BarrierIterations","text":"BarrierIterations\n\nNumber of iterations of the barrier algorithm in the last call.\n\nThis number may be zero in the following cases:\n\nthe model has been solved yet\npresolve solved the model\nthe initial solution was optimal\n\nType: Int\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.BarrierIterations())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.DualObjectiveValue","page":"Attributes","title":"Tulip.DualObjectiveValue","text":"DualObjectiveValue\n\nObjective value of the current dual solution.\n\nType: Tv\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.DualObjectiveValue())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ModelName","page":"Attributes","title":"Tulip.ModelName","text":"ModelName\n\nThe name of the model.\n\nType: String\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ModelName(), \"lp_example\")\nTulip.get_attribute(model, Tulip.ModelName())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.NumberOfConstraints","page":"Attributes","title":"Tulip.NumberOfConstraints","text":"NumberOfConstraints\n\nNumber of constraints in the model.\n\nType: Int\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.NumberOfConstraints())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.NumberOfVariables","page":"Attributes","title":"Tulip.NumberOfVariables","text":"NumberOfVariables\n\nNumber of variables in the model.\n\nType: Int\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.NumberOfVariables())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ObjectiveConstant","page":"Attributes","title":"Tulip.ObjectiveConstant","text":"ObjectiveConstant\n\nConstant objective offset, defaults to zero.\n\nType: Tv\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ObjectiveConstant(), zero(Tv))\nTulip.get_attribute(model, Tulip.ObjectiveConstant())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ObjectiveSense","page":"Attributes","title":"Tulip.ObjectiveSense","text":"ObjectiveSense\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ObjectiveValue","page":"Attributes","title":"Tulip.ObjectiveValue","text":"ObjectiveValue\n\nObjective value of the current primal solution.\n\nType: Tv\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.ObjectiveValue())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.SolutionTime","page":"Attributes","title":"Tulip.SolutionTime","text":"SolutionTime\n\nTotal solution time, in seconds.\n\nType: Float64\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.SolutionTime())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.Status","page":"Attributes","title":"Tulip.Status","text":"Status\n\nModel status\n\nType:\n\nModifiable: No\n\nExamples\n\nTulip.get(model, Tulip.Status())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Variable-attributes-2","page":"Attributes","title":"Variable attributes","text":"","category":"section"},{"location":"reference/attributes/#","page":"Attributes","title":"Attributes","text":"Modules = [Tulip]\nPages = [\"src/Core/attributes.jl\"]\nFilter = t -> typeof(t) === DataType && t <: Tulip.AbstractVariableAttribute","category":"page"},{"location":"reference/attributes/#Tulip.VariableLowerBound","page":"Attributes","title":"Tulip.VariableLowerBound","text":"VariableLowerBound\n\nVariable lower bound.\n\nType: Tv\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableLowerBound(), 1, zero(Tv))\nTulip.get_attribute(model, Tulip.VariableLowerBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.VariableName","page":"Attributes","title":"Tulip.VariableName","text":"VariableName\n\nName of the variable.\n\nType: String\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableName(), 1, \"x1\")\nTulip.get_attribute(model, Tulip.VariableName(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.VariableObjectiveCoeff","page":"Attributes","title":"Tulip.VariableObjectiveCoeff","text":"VariableObjectiveCoeff\n\nObjective coefficient of the variable.\n\nType: Tv\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableObjectiveCoeff(), 1, one(Tv))\nTulip.get_attribute(model, Tulip.VariableObjectiveCoeff(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.VariableUpperBound","page":"Attributes","title":"Tulip.VariableUpperBound","text":"VariableUpperBound\n\nVariable upper bound.\n\nType: Tv\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableUpperBound(), 1, one(Tv))\nTulip.get_attribute(model, Tulip.VariableUpperBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Constraint-attributes-2","page":"Attributes","title":"Constraint attributes","text":"","category":"section"},{"location":"reference/attributes/#","page":"Attributes","title":"Attributes","text":"Modules = [Tulip]\nPages = [\"src/Core/attributes.jl\"]\nFilter = t -> typeof(t) === DataType && t <: Tulip.AbstractConstraintAttribute","category":"page"},{"location":"reference/attributes/#Tulip.ConstraintLowerBound","page":"Attributes","title":"Tulip.ConstraintLowerBound","text":"ConstraintLowerBound\n\nConstraint lower bound.\n\nType: Tv\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ConstraintLowerBound(), 1, zero(Tv))\nTulip.get_attribute(model, Tulip.ConstraintLowerBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ConstraintName","page":"Attributes","title":"Tulip.ConstraintName","text":"ConstraintName\n\nName of the constraint.\n\nType: String\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ConstraintName(), 1, \"c1\")\nTulip.get_attribute(model, Tulip.ConstraintName(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ConstraintUpperBound","page":"Attributes","title":"Tulip.ConstraintUpperBound","text":"ConstraintUpperBound\n\nConstraint upper bound.\n\nType: Tv\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ConstraintUpperBound(), 1, one(Tv))\nTulip.get_attribute(model, Tulip.ConstraintUpperBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/linear_solvers/#","page":"Linear solvers","title":"Linear solvers","text":"CurrentModule = Tulip.TLPLinearAlgebra","category":"page"},{"location":"reference/linear_solvers/#AbstractLinearSolver-1","page":"Linear solvers","title":"AbstractLinearSolver","text":"","category":"section"},{"location":"reference/linear_solvers/#","page":"Linear solvers","title":"Linear solvers","text":"This is the base type from which all implementations should derive.","category":"page"},{"location":"reference/linear_solvers/#","page":"Linear solvers","title":"Linear solvers","text":"AbstractLinearSolver","category":"page"},{"location":"reference/linear_solvers/#Tulip.TLPLinearAlgebra.AbstractLinearSolver","page":"Linear solvers","title":"Tulip.TLPLinearAlgebra.AbstractLinearSolver","text":"AbstractLinearSolver{Tv}\n\nAbstract container for solving an augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [ξd]\n    [   A          Rd] [dy]   [ξp]\n\nwhere ξd and ξp are given right-hand side.\n\n\n\n\n\n","category":"type"},{"location":"reference/linear_solvers/#","page":"Linear solvers","title":"Linear solvers","text":"Custom linear solvers should inherit from the AbstractLinearSolver class, and extend the following two functions:","category":"page"},{"location":"reference/linear_solvers/#","page":"Linear solvers","title":"Linear solvers","text":"update_linear_solver!","category":"page"},{"location":"reference/linear_solvers/#Tulip.TLPLinearAlgebra.update_linear_solver!","page":"Linear solvers","title":"Tulip.TLPLinearAlgebra.update_linear_solver!","text":"update_linear_solver!(ls, θ, regP, regD)\n\nUpdate internal data, and re-compute factorization/pre-conditioner.\n\nAfter this call, ls can be used to solve the augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [ξd]\n    [   A          Rd] [dy]   [ξp]\n\nfor given right-hand sides ξd and ξp.\n\n\n\n\n\n","category":"function"},{"location":"reference/linear_solvers/#","page":"Linear solvers","title":"Linear solvers","text":"solve_augmented_system!","category":"page"},{"location":"reference/linear_solvers/#Tulip.TLPLinearAlgebra.solve_augmented_system!","page":"Linear solvers","title":"Tulip.TLPLinearAlgebra.solve_augmented_system!","text":"solve_augmented_system!(dx, dy, ls, ξp, ξd)\n\nSolve the symmetric quasi-definite augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [ξd]\n    [   A          Rd] [dy]   [ξp]\n\nand over-write dx, dy with the result.\n\nArguments\n\ndx, dy: Vectors of unknowns, modified in-place\nls: Linear solver for the augmented system\nξp, ξd: Right-hand-side vectors\n\n\n\n\n\n","category":"function"},{"location":"reference/linear_solvers/#DenseLinearSolver-1","page":"Linear solvers","title":"DenseLinearSolver","text":"","category":"section"},{"location":"reference/linear_solvers/#","page":"Linear solvers","title":"Linear solvers","text":"DenseLinearSolver","category":"page"},{"location":"reference/linear_solvers/#Tulip.TLPLinearAlgebra.DenseLinearSolver","page":"Linear solvers","title":"Tulip.TLPLinearAlgebra.DenseLinearSolver","text":"DenseLinearSolver{Tv}\n\nLinear solver for the 2x2 augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [xi_d]\n    [   A          Rd] [dy]   [xi_p]\n\nwith A dense.\n\nThe augmented system is automatically reduced to the normal equations system. BLAS/LAPACK functions are used whenever applicable.\n\n\n\n\n\n","category":"type"},{"location":"reference/linear_solvers/#","page":"Linear solvers","title":"Linear solvers","text":"update_linear_solver!(::DenseLinearSolver{Tv},::AbstractVector{Tv},::AbstractVector{Tv},::AbstractVector{Tv}) where{Tv<:Real}\nupdate_linear_solver!(::DenseLinearSolver{Tv},::AbstractVector{Tv},::AbstractVector{Tv},::AbstractVector{Tv}) where{Tv<:BlasReal}","category":"page"},{"location":"reference/linear_solvers/#Tulip.TLPLinearAlgebra.update_linear_solver!-Union{Tuple{Tv}, Tuple{Tulip.TLPLinearAlgebra.DenseLinearSolver{Tv},AbstractArray{Tv,1},AbstractArray{Tv,1},AbstractArray{Tv,1}}} where Tv<:Real","page":"Linear solvers","title":"Tulip.TLPLinearAlgebra.update_linear_solver!","text":"update_linear_solver!(ls::DenseLinearSolver{<:Real}, θ, regP, regD)\n\nCompute normal equations system matrix and update Cholesky factorization.\n\nUses Julia's generic linear algebra.\n\n\n\n\n\n","category":"method"},{"location":"reference/linear_solvers/#Tulip.TLPLinearAlgebra.update_linear_solver!-Union{Tuple{Tv}, Tuple{Tulip.TLPLinearAlgebra.DenseLinearSolver{Tv},AbstractArray{Tv,1},AbstractArray{Tv,1},AbstractArray{Tv,1}}} where Tv<:Union{Float32, Float64}","page":"Linear solvers","title":"Tulip.TLPLinearAlgebra.update_linear_solver!","text":"update_linear_solver!(ls::DenseLinearSolver{<:BlasReal}, θ, regP, regD)\n\nCompute normal equations system matrix and update Cholesky factorization.\n\nUses BLAS and LAPACK routines.\n\n\n\n\n\n","category":"method"},{"location":"reference/linear_solvers/#","page":"Linear solvers","title":"Linear solvers","text":"solve_augmented_system!(::Vector{Tv},::Vector{Tv},::DenseLinearSolver{Tv}, ::Vector{Tv}, ::Vector{Tv}) where{Tv<:Real}\nsolve_augmented_system!(::Vector{Tv},::Vector{Tv},::DenseLinearSolver{Tv}, ::Vector{Tv}, ::Vector{Tv}) where{Tv<:BlasReal}","category":"page"},{"location":"reference/linear_solvers/#Tulip.TLPLinearAlgebra.solve_augmented_system!-Union{Tuple{Tv}, Tuple{Array{Tv,1},Array{Tv,1},Tulip.TLPLinearAlgebra.DenseLinearSolver{Tv},Array{Tv,1},Array{Tv,1}}} where Tv<:Real","page":"Linear solvers","title":"Tulip.TLPLinearAlgebra.solve_augmented_system!","text":"solve_augmented_system!(dx, dy, ls, ξp, ξd)\n\nSolve the augmented system, overwriting dx, dy with the result.\n\nUses two generic triangular solves for solving the normal equations system.\n\n\n\n\n\n","category":"method"},{"location":"reference/linear_solvers/#Tulip.TLPLinearAlgebra.solve_augmented_system!-Union{Tuple{Tv}, Tuple{Array{Tv,1},Array{Tv,1},Tulip.TLPLinearAlgebra.DenseLinearSolver{Tv},Array{Tv,1},Array{Tv,1}}} where Tv<:Union{Float32, Float64}","page":"Linear solvers","title":"Tulip.TLPLinearAlgebra.solve_augmented_system!","text":"solve_augmented_system!(dx, dy, ls, ξp, ξd)\n\nSolve the augmented system, overwriting dx, dy with the result.\n\nUses one LAPACK call for solving the normal equations system.\n\n\n\n\n\n","category":"method"},{"location":"reference/linear_solvers/#SparseIndefLinearSolver-1","page":"Linear solvers","title":"SparseIndefLinearSolver","text":"","category":"section"},{"location":"reference/linear_solvers/#","page":"Linear solvers","title":"Linear solvers","text":"SparseIndefLinearSolver","category":"page"},{"location":"reference/linear_solvers/#Tulip.TLPLinearAlgebra.SparseIndefLinearSolver","page":"Linear solvers","title":"Tulip.TLPLinearAlgebra.SparseIndefLinearSolver","text":"SparseIndefLinearSolver\n\nLinear solver for the 2x2 augmented system with A sparse.\n\nUses an LDLᵀ factorization of the quasi-definite augmented system.\n\n\n\n\n\n","category":"type"},{"location":"reference/linear_solvers/#","page":"Linear solvers","title":"Linear solvers","text":"update_linear_solver!(::SparseIndefLinearSolver,::AbstractVector{Float64},::AbstractVector{Float64},::AbstractVector{Float64})","category":"page"},{"location":"reference/linear_solvers/#Tulip.TLPLinearAlgebra.update_linear_solver!-Tuple{Tulip.TLPLinearAlgebra.SparseIndefLinearSolver,AbstractArray{Float64,1},AbstractArray{Float64,1},AbstractArray{Float64,1}}","page":"Linear solvers","title":"Tulip.TLPLinearAlgebra.update_linear_solver!","text":"update_linear_solver!(ls, θ, regP, regD)\n\nUpdate LDLᵀ factorization of the augmented system.\n\nUpdate diagonal scaling theta, primal-dual regularizations, and re-compute     the factorization. Throws a PosDefException if matrix is not quasi-definite.\n\n\n\n\n\n","category":"method"},{"location":"reference/linear_solvers/#","page":"Linear solvers","title":"Linear solvers","text":"solve_augmented_system!(::Vector{Float64},::Vector{Float64},::SparseIndefLinearSolver, ::Vector{Float64}, ::Vector{Float64})","category":"page"},{"location":"reference/linear_solvers/#Tulip.TLPLinearAlgebra.solve_augmented_system!-Tuple{Array{Float64,1},Array{Float64,1},Tulip.TLPLinearAlgebra.SparseIndefLinearSolver,Array{Float64,1},Array{Float64,1}}","page":"Linear solvers","title":"Tulip.TLPLinearAlgebra.solve_augmented_system!","text":"solve_augmented_system!(dx, dy, ls, ξp, ξd)\n\nSolve the augmented system, overwriting dx, dy with the result.\n\n\n\n\n\n","category":"method"},{"location":"reference/linear_solvers/#SparsePosDefLinearSolver-1","page":"Linear solvers","title":"SparsePosDefLinearSolver","text":"","category":"section"},{"location":"reference/linear_solvers/#","page":"Linear solvers","title":"Linear solvers","text":"SparsePosDefLinearSolver","category":"page"},{"location":"reference/linear_solvers/#Tulip.TLPLinearAlgebra.SparsePosDefLinearSolver","page":"Linear solvers","title":"Tulip.TLPLinearAlgebra.SparsePosDefLinearSolver","text":"SparsePosDefLinearSolver\n\nLinear solver for the 2x2 augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [xi_d]\n    [   A          Rd] [dy]   [xi_p]\n\nwith A sparse.\n\nUses a Cholesky factorization of the positive definite normal equations system\n\n(A * ((Θ⁻¹ + Rp)⁻¹ * Aᵀ + Rd) dy = xi_p + A * (θ⁻¹ + Rp)⁻¹ * xi_d\n                              dx = (Θ⁻¹ + Rp)⁻¹ * (Aᵀ * dy - xi_d)\n\n\n\n\n\n","category":"type"},{"location":"reference/linear_solvers/#","page":"Linear solvers","title":"Linear solvers","text":"update_linear_solver!(::SparsePosDefLinearSolver,::AbstractVector{Float64},::AbstractVector{Float64},::AbstractVector{Float64})","category":"page"},{"location":"reference/linear_solvers/#Tulip.TLPLinearAlgebra.update_linear_solver!-Tuple{Tulip.TLPLinearAlgebra.SparsePosDefLinearSolver,AbstractArray{Float64,1},AbstractArray{Float64,1},AbstractArray{Float64,1}}","page":"Linear solvers","title":"Tulip.TLPLinearAlgebra.update_linear_solver!","text":"update_linear_solver!(ls, θ, regP, regD)\n\nCompute normal equation system matrix, and update the factorization.\n\n\n\n\n\n","category":"method"},{"location":"reference/linear_solvers/#","page":"Linear solvers","title":"Linear solvers","text":"solve_augmented_system!(::Vector{Float64},::Vector{Float64},::SparsePosDefLinearSolver, ::Vector{Float64}, ::Vector{Float64})","category":"page"},{"location":"reference/linear_solvers/#Tulip.TLPLinearAlgebra.solve_augmented_system!-Tuple{Array{Float64,1},Array{Float64,1},Tulip.TLPLinearAlgebra.SparsePosDefLinearSolver,Array{Float64,1},Array{Float64,1}}","page":"Linear solvers","title":"Tulip.TLPLinearAlgebra.solve_augmented_system!","text":"solve_augmented_system!(dx, dy, ls, ξp, ξd)\n\nSolve the augmented system, overwriting dx, dy with the result.\n\n\n\n\n\n","category":"method"},{"location":"reference/linear_solvers/#LDLFLinearSolver-1","page":"Linear solvers","title":"LDLFLinearSolver","text":"","category":"section"},{"location":"reference/linear_solvers/#","page":"Linear solvers","title":"Linear solvers","text":"LDLFLinearSolver","category":"page"},{"location":"reference/linear_solvers/#Tulip.TLPLinearAlgebra.LDLFLinearSolver","page":"Linear solvers","title":"Tulip.TLPLinearAlgebra.LDLFLinearSolver","text":"LDLFLinearSolver{Tv}\n\nLinear solver for the 2x2 augmented system with A sparse.\n\nUses LDLFactorizations.jl to compute an LDLᵀ factorization of the quasi-definite augmented system.\n\n\n\n\n\n","category":"type"},{"location":"reference/linear_solvers/#","page":"Linear solvers","title":"Linear solvers","text":"update_linear_solver!(::LDLFLinearSolver{Tv},::AbstractVector{Tv},::AbstractVector{Tv},::AbstractVector{Tv}) where{Tv<:Real}","category":"page"},{"location":"reference/linear_solvers/#Tulip.TLPLinearAlgebra.update_linear_solver!-Union{Tuple{Tv}, Tuple{Tulip.TLPLinearAlgebra.LDLFLinearSolver{Tv},AbstractArray{Tv,1},AbstractArray{Tv,1},AbstractArray{Tv,1}}} where Tv<:Real","page":"Linear solvers","title":"Tulip.TLPLinearAlgebra.update_linear_solver!","text":"update_linear_solver!(ls, θ, regP, regD)\n\nUpdate LDLᵀ factorization of the augmented system.\n\nUpdate diagonal scaling theta, primal-dual regularizations, and re-compute     the factorization. Throws a PosDefException if matrix is not quasi-definite.\n\n\n\n\n\n","category":"method"},{"location":"reference/linear_solvers/#","page":"Linear solvers","title":"Linear solvers","text":"solve_augmented_system!(::Vector{Tv},::Vector{Tv},::LDLFLinearSolver{Tv}, ::Vector{Tv}, ::Vector{Tv}) where{Tv<:Real}","category":"page"},{"location":"reference/linear_solvers/#Tulip.TLPLinearAlgebra.solve_augmented_system!-Union{Tuple{Tv}, Tuple{Array{Tv,1},Array{Tv,1},Tulip.TLPLinearAlgebra.LDLFLinearSolver{Tv},Array{Tv,1},Array{Tv,1}}} where Tv<:Real","page":"Linear solvers","title":"Tulip.TLPLinearAlgebra.solve_augmented_system!","text":"solve_augmented_system!(dx, dy, ls, ξp, ξd)\n\nSolve the augmented system, overwriting dx, dy with the result.\n\n\n\n\n\n","category":"method"},{"location":"#","page":"Home","title":"Home","text":"CurrentModule = Tulip","category":"page"},{"location":"#Tulip.jl-1","page":"Home","title":"Tulip.jl","text":"","category":"section"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Tulip is an open-source interior-point solver for linear programming.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Tulip is 100% Julia, so install it just like any Julia package:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> ]\npkg> add Tulip","category":"page"},{"location":"#","page":"Home","title":"Home","text":"No additional building step is required.","category":"page"},{"location":"#Citing-Tulip.jl-1","page":"Home","title":"Citing Tulip.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If you use Tulip in your work, we kindly ask that you cite the following reference. The PDF is freely available here, and serves as a user manual for advanced users.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@TechReport{Tulip.jl,\n    title = {{Tulip}.jl: an open-source interior-point linear optimization\n    solver with abstract linear algebra},\n    url = {https://www.gerad.ca/fr/papers/G-2019-36},\n    Journal = {Les Cahiers du Gerad},\n    Author = {Anjos, Miguel F. and Lodi, Andrea and Tanneau, Mathieu},\n    year = {2019}\n}","category":"page"}]
}
